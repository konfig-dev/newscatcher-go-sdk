/*
NewsCatcher-V3 Production API

<img src='https://uploads-ssl.webflow.com/6429857b17973b636c2195c5/646c6f1eb774ff2f2997bec5_newscatcher_.svg' width='286' height='35' /> <br>  <br>Visit our website  <a href='https://newscatcherapi.com'>https://newscatcherapi.com</a>

API version: Beta-3.0.0
Contact: maksym@newscatcherapi.com
*/

// Code generated by Konfig (https://konfigthis.com); DO NOT EDIT.

package newscatcherapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
)


// AuthorsApiService AuthorsApi service
type AuthorsApiService service

type AuthorsApiGetRequest struct {
	ctx context.Context
	ApiService *AuthorsApiService
	authorName string
	sources *string
	predefinedSources *string
	notSources *string
	lang *string
	notLang *string
	countries *string
	notCountries *string
	from *From
	to *To
	publishedDatePrecision *string
	byParseDate *bool
	sortBy *string
	rankedOnly *string
	fromRank *int32
	toRank *int32
	isHeadline *bool
	isPaidContent *bool
	parentUrl *string
	allLinks *string
	allDomainLinks *string
	wordCountMin *int32
	wordCountMax *int32
	page *int32
	pageSize *int32
	includeNlpData *bool
	hasNlp *bool
	theme *string
	nerName *string
	titleSentimentMin *float32
	titleSentimentMax *float32
	contentSentimentMin *float32
	contentSentimentMax *float32
}

func (r *AuthorsApiGetRequest) Sources(sources string) *AuthorsApiGetRequest {
	r.sources = &sources
	return r
}

func (r *AuthorsApiGetRequest) PredefinedSources(predefinedSources string) *AuthorsApiGetRequest {
	r.predefinedSources = &predefinedSources
	return r
}

func (r *AuthorsApiGetRequest) NotSources(notSources string) *AuthorsApiGetRequest {
	r.notSources = &notSources
	return r
}

func (r *AuthorsApiGetRequest) Lang(lang string) *AuthorsApiGetRequest {
	r.lang = &lang
	return r
}

func (r *AuthorsApiGetRequest) NotLang(notLang string) *AuthorsApiGetRequest {
	r.notLang = &notLang
	return r
}

func (r *AuthorsApiGetRequest) Countries(countries string) *AuthorsApiGetRequest {
	r.countries = &countries
	return r
}

func (r *AuthorsApiGetRequest) NotCountries(notCountries string) *AuthorsApiGetRequest {
	r.notCountries = &notCountries
	return r
}

func (r *AuthorsApiGetRequest) From(from From) *AuthorsApiGetRequest {
	r.from = &from
	return r
}

func (r *AuthorsApiGetRequest) To(to To) *AuthorsApiGetRequest {
	r.to = &to
	return r
}

func (r *AuthorsApiGetRequest) PublishedDatePrecision(publishedDatePrecision string) *AuthorsApiGetRequest {
	r.publishedDatePrecision = &publishedDatePrecision
	return r
}

func (r *AuthorsApiGetRequest) ByParseDate(byParseDate bool) *AuthorsApiGetRequest {
	r.byParseDate = &byParseDate
	return r
}

func (r *AuthorsApiGetRequest) SortBy(sortBy string) *AuthorsApiGetRequest {
	r.sortBy = &sortBy
	return r
}

func (r *AuthorsApiGetRequest) RankedOnly(rankedOnly string) *AuthorsApiGetRequest {
	r.rankedOnly = &rankedOnly
	return r
}

func (r *AuthorsApiGetRequest) FromRank(fromRank int32) *AuthorsApiGetRequest {
	r.fromRank = &fromRank
	return r
}

func (r *AuthorsApiGetRequest) ToRank(toRank int32) *AuthorsApiGetRequest {
	r.toRank = &toRank
	return r
}

func (r *AuthorsApiGetRequest) IsHeadline(isHeadline bool) *AuthorsApiGetRequest {
	r.isHeadline = &isHeadline
	return r
}

func (r *AuthorsApiGetRequest) IsPaidContent(isPaidContent bool) *AuthorsApiGetRequest {
	r.isPaidContent = &isPaidContent
	return r
}

func (r *AuthorsApiGetRequest) ParentUrl(parentUrl string) *AuthorsApiGetRequest {
	r.parentUrl = &parentUrl
	return r
}

func (r *AuthorsApiGetRequest) AllLinks(allLinks string) *AuthorsApiGetRequest {
	r.allLinks = &allLinks
	return r
}

func (r *AuthorsApiGetRequest) AllDomainLinks(allDomainLinks string) *AuthorsApiGetRequest {
	r.allDomainLinks = &allDomainLinks
	return r
}

func (r *AuthorsApiGetRequest) WordCountMin(wordCountMin int32) *AuthorsApiGetRequest {
	r.wordCountMin = &wordCountMin
	return r
}

func (r *AuthorsApiGetRequest) WordCountMax(wordCountMax int32) *AuthorsApiGetRequest {
	r.wordCountMax = &wordCountMax
	return r
}

func (r *AuthorsApiGetRequest) Page(page int32) *AuthorsApiGetRequest {
	r.page = &page
	return r
}

func (r *AuthorsApiGetRequest) PageSize(pageSize int32) *AuthorsApiGetRequest {
	r.pageSize = &pageSize
	return r
}

func (r *AuthorsApiGetRequest) IncludeNlpData(includeNlpData bool) *AuthorsApiGetRequest {
	r.includeNlpData = &includeNlpData
	return r
}

func (r *AuthorsApiGetRequest) HasNlp(hasNlp bool) *AuthorsApiGetRequest {
	r.hasNlp = &hasNlp
	return r
}

func (r *AuthorsApiGetRequest) Theme(theme string) *AuthorsApiGetRequest {
	r.theme = &theme
	return r
}

func (r *AuthorsApiGetRequest) NerName(nerName string) *AuthorsApiGetRequest {
	r.nerName = &nerName
	return r
}

func (r *AuthorsApiGetRequest) TitleSentimentMin(titleSentimentMin float32) *AuthorsApiGetRequest {
	r.titleSentimentMin = &titleSentimentMin
	return r
}

func (r *AuthorsApiGetRequest) TitleSentimentMax(titleSentimentMax float32) *AuthorsApiGetRequest {
	r.titleSentimentMax = &titleSentimentMax
	return r
}

func (r *AuthorsApiGetRequest) ContentSentimentMin(contentSentimentMin float32) *AuthorsApiGetRequest {
	r.contentSentimentMin = &contentSentimentMin
	return r
}

func (r *AuthorsApiGetRequest) ContentSentimentMax(contentSentimentMax float32) *AuthorsApiGetRequest {
	r.contentSentimentMax = &contentSentimentMax
	return r
}

func (r AuthorsApiGetRequest) Execute() (*AuthorsGetResponse, *http.Response, error) {
	return r.ApiService.GetExecute(r)
}

/*
Get [Get] Search By Author Request

This endpoint allows you to search for articles by author. You need to specify the author name. You can also filter by language, country, source, and more.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param authorName
 @return AuthorsApiGetRequest
*/
func (a *AuthorsApiService) Get(authorName string) AuthorsApiGetRequest {
	return AuthorsApiGetRequest{
		ApiService: a,
		ctx: a.client.cfg.Context,
		authorName: authorName,
	}
}

// Execute executes the request
//  @return AuthorsGetResponse
func (a *AuthorsApiService) GetExecute(r AuthorsApiGetRequest) (*AuthorsGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthorsGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthorsApiService.Get")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/authors"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if *r.wordCountMin < 0 {
		return localVarReturnValue, nil, reportError("wordCountMin must be greater than 0")
	}
	if *r.wordCountMax < 0 {
		return localVarReturnValue, nil, reportError("wordCountMax must be greater than 0")
	}
	if *r.page < 0 {
		return localVarReturnValue, nil, reportError("page must be greater than 0")
	}
	if *r.pageSize < 0 {
		return localVarReturnValue, nil, reportError("pageSize must be greater than 0")
	}

	localVarQueryParams.Add("author_name", parameterToString(r.authorName, ""))
	if r.sources != nil {
		localVarQueryParams.Add("sources", parameterToString(*r.sources, ""))
	}
	if r.predefinedSources != nil {
		localVarQueryParams.Add("predefined_sources", parameterToString(*r.predefinedSources, ""))
	}
	if r.notSources != nil {
		localVarQueryParams.Add("not_sources", parameterToString(*r.notSources, ""))
	}
	if r.lang != nil {
		localVarQueryParams.Add("lang", parameterToString(*r.lang, ""))
	}
	if r.notLang != nil {
		localVarQueryParams.Add("not_lang", parameterToString(*r.notLang, ""))
	}
	if r.countries != nil {
		localVarQueryParams.Add("countries", parameterToString(*r.countries, ""))
	}
	if r.notCountries != nil {
		localVarQueryParams.Add("not_countries", parameterToString(*r.notCountries, ""))
	}
	if r.from != nil {
		localVarQueryParams.Add("from_", parameterToString(*r.from, ""))
	}
	if r.to != nil {
		localVarQueryParams.Add("to_", parameterToString(*r.to, ""))
	}
	if r.publishedDatePrecision != nil {
		localVarQueryParams.Add("published_date_precision", parameterToString(*r.publishedDatePrecision, ""))
	}
	if r.byParseDate != nil {
		localVarQueryParams.Add("by_parse_date", parameterToString(*r.byParseDate, ""))
	}
	if r.sortBy != nil {
		localVarQueryParams.Add("sort_by", parameterToString(*r.sortBy, ""))
	}
	if r.rankedOnly != nil {
		localVarQueryParams.Add("ranked_only", parameterToString(*r.rankedOnly, ""))
	}
	if r.fromRank != nil {
		localVarQueryParams.Add("from_rank", parameterToString(*r.fromRank, ""))
	}
	if r.toRank != nil {
		localVarQueryParams.Add("to_rank", parameterToString(*r.toRank, ""))
	}
	if r.isHeadline != nil {
		localVarQueryParams.Add("is_headline", parameterToString(*r.isHeadline, ""))
	}
	if r.isPaidContent != nil {
		localVarQueryParams.Add("is_paid_content", parameterToString(*r.isPaidContent, ""))
	}
	if r.parentUrl != nil {
		localVarQueryParams.Add("parent_url", parameterToString(*r.parentUrl, ""))
	}
	if r.allLinks != nil {
		localVarQueryParams.Add("all_links", parameterToString(*r.allLinks, ""))
	}
	if r.allDomainLinks != nil {
		localVarQueryParams.Add("all_domain_links", parameterToString(*r.allDomainLinks, ""))
	}
	if r.wordCountMin != nil {
		localVarQueryParams.Add("word_count_min", parameterToString(*r.wordCountMin, ""))
	}
	if r.wordCountMax != nil {
		localVarQueryParams.Add("word_count_max", parameterToString(*r.wordCountMax, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.includeNlpData != nil {
		localVarQueryParams.Add("include_nlp_data", parameterToString(*r.includeNlpData, ""))
	}
	if r.hasNlp != nil {
		localVarQueryParams.Add("has_nlp", parameterToString(*r.hasNlp, ""))
	}
	if r.theme != nil {
		localVarQueryParams.Add("theme", parameterToString(*r.theme, ""))
	}
	if r.nerName != nil {
		localVarQueryParams.Add("ner_name", parameterToString(*r.nerName, ""))
	}
	if r.titleSentimentMin != nil {
		localVarQueryParams.Add("title_sentiment_min", parameterToString(*r.titleSentimentMin, ""))
	}
	if r.titleSentimentMax != nil {
		localVarQueryParams.Add("title_sentiment_max", parameterToString(*r.titleSentimentMax, ""))
	}
	if r.contentSentimentMin != nil {
		localVarQueryParams.Add("content_sentiment_min", parameterToString(*r.contentSentimentMin, ""))
	}
	if r.contentSentimentMax != nil {
		localVarQueryParams.Add("content_sentiment_max", parameterToString(*r.contentSentimentMax, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AuthorsApiPostRequest struct {
	ctx context.Context
	ApiService *AuthorsApiService
	authorSearchRequest AuthorSearchRequest
}

func (r AuthorsApiPostRequest) Execute() (*AuthorsPostResponse, *http.Response, error) {
	return r.ApiService.PostExecute(r)
}

/*
Post [Post] Search By Author Request

This endpoint allows you to search for articles by author. You need to specify the author name. You can also filter by language, country, source, and more.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param authorSearchRequest
 @return AuthorsApiPostRequest
*/
func (a *AuthorsApiService) Post(authorSearchRequest AuthorSearchRequest) AuthorsApiPostRequest {
	return AuthorsApiPostRequest{
		ApiService: a,
		ctx: a.client.cfg.Context,
		authorSearchRequest: authorSearchRequest,
	}
}

// Execute executes the request
//  @return AuthorsPostResponse
func (a *AuthorsApiService) PostExecute(r AuthorsApiPostRequest) (*AuthorsPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthorsPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthorsApiService.Post")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/authors"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authorSearchRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
