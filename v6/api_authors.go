/*
NewsCatcher-V3 Production API

<img src='https://uploads-ssl.webflow.com/6429857b17973b636c2195c5/646c6f1eb774ff2f2997bec5_newscatcher_.svg' width='286' height='35' /> <br>  <br>Visit our website  <a href='https://newscatcherapi.com'>https://newscatcherapi.com</a>

API version: 3.2.16
Contact: maksym@newscatcherapi.com
*/

// Code generated by Konfig (https://konfigthis.com); DO NOT EDIT.

package newscatcherapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
)


// AuthorsApiService AuthorsApi service
type AuthorsApiService service

type AuthorsApiGetRequest struct {
	ctx context.Context
	ApiService *AuthorsApiService
	authorName string
	notAuthorName *string
	sources *interface{}
	predefinedSources *interface{}
	notSources *interface{}
	lang *interface{}
	notLang *interface{}
	countries *interface{}
	notCountries *interface{}
	from *string
	to *string
	publishedDatePrecision *string
	byParseDate *bool
	sortBy *string
	rankedOnly *string
	fromRank *int32
	toRank *int32
	isHeadline *bool
	isOpinion *bool
	isPaidContent *bool
	parentUrl *interface{}
	allLinks *interface{}
	allDomainLinks *interface{}
	wordCountMin *int32
	wordCountMax *int32
	page *int32
	pageSize *int32
	includeNlpData *bool
	hasNlp *bool
	theme *string
	notTheme *string
	nerName *string
	titleSentimentMin *float32
	titleSentimentMax *float32
	contentSentimentMin *float32
	contentSentimentMax *float32
	iptcTags *interface{}
	notIptcTags *interface{}
	iabTags *interface{}
	notIabTags *interface{}
}

func (r *AuthorsApiGetRequest) NotAuthorName(notAuthorName string) *AuthorsApiGetRequest {
	r.notAuthorName = &notAuthorName
	return r
}

func (r *AuthorsApiGetRequest) Sources(sources interface{}) *AuthorsApiGetRequest {
	r.sources = &sources
	return r
}

func (r *AuthorsApiGetRequest) PredefinedSources(predefinedSources interface{}) *AuthorsApiGetRequest {
	r.predefinedSources = &predefinedSources
	return r
}

func (r *AuthorsApiGetRequest) NotSources(notSources interface{}) *AuthorsApiGetRequest {
	r.notSources = &notSources
	return r
}

func (r *AuthorsApiGetRequest) Lang(lang interface{}) *AuthorsApiGetRequest {
	r.lang = &lang
	return r
}

func (r *AuthorsApiGetRequest) NotLang(notLang interface{}) *AuthorsApiGetRequest {
	r.notLang = &notLang
	return r
}

func (r *AuthorsApiGetRequest) Countries(countries interface{}) *AuthorsApiGetRequest {
	r.countries = &countries
	return r
}

func (r *AuthorsApiGetRequest) NotCountries(notCountries interface{}) *AuthorsApiGetRequest {
	r.notCountries = &notCountries
	return r
}

func (r *AuthorsApiGetRequest) From(from string) *AuthorsApiGetRequest {
	r.from = &from
	return r
}

func (r *AuthorsApiGetRequest) To(to string) *AuthorsApiGetRequest {
	r.to = &to
	return r
}

func (r *AuthorsApiGetRequest) PublishedDatePrecision(publishedDatePrecision string) *AuthorsApiGetRequest {
	r.publishedDatePrecision = &publishedDatePrecision
	return r
}

func (r *AuthorsApiGetRequest) ByParseDate(byParseDate bool) *AuthorsApiGetRequest {
	r.byParseDate = &byParseDate
	return r
}

func (r *AuthorsApiGetRequest) SortBy(sortBy string) *AuthorsApiGetRequest {
	r.sortBy = &sortBy
	return r
}

func (r *AuthorsApiGetRequest) RankedOnly(rankedOnly string) *AuthorsApiGetRequest {
	r.rankedOnly = &rankedOnly
	return r
}

func (r *AuthorsApiGetRequest) FromRank(fromRank int32) *AuthorsApiGetRequest {
	r.fromRank = &fromRank
	return r
}

func (r *AuthorsApiGetRequest) ToRank(toRank int32) *AuthorsApiGetRequest {
	r.toRank = &toRank
	return r
}

func (r *AuthorsApiGetRequest) IsHeadline(isHeadline bool) *AuthorsApiGetRequest {
	r.isHeadline = &isHeadline
	return r
}

func (r *AuthorsApiGetRequest) IsOpinion(isOpinion bool) *AuthorsApiGetRequest {
	r.isOpinion = &isOpinion
	return r
}

func (r *AuthorsApiGetRequest) IsPaidContent(isPaidContent bool) *AuthorsApiGetRequest {
	r.isPaidContent = &isPaidContent
	return r
}

func (r *AuthorsApiGetRequest) ParentUrl(parentUrl interface{}) *AuthorsApiGetRequest {
	r.parentUrl = &parentUrl
	return r
}

func (r *AuthorsApiGetRequest) AllLinks(allLinks interface{}) *AuthorsApiGetRequest {
	r.allLinks = &allLinks
	return r
}

func (r *AuthorsApiGetRequest) AllDomainLinks(allDomainLinks interface{}) *AuthorsApiGetRequest {
	r.allDomainLinks = &allDomainLinks
	return r
}

func (r *AuthorsApiGetRequest) WordCountMin(wordCountMin int32) *AuthorsApiGetRequest {
	r.wordCountMin = &wordCountMin
	return r
}

func (r *AuthorsApiGetRequest) WordCountMax(wordCountMax int32) *AuthorsApiGetRequest {
	r.wordCountMax = &wordCountMax
	return r
}

func (r *AuthorsApiGetRequest) Page(page int32) *AuthorsApiGetRequest {
	r.page = &page
	return r
}

func (r *AuthorsApiGetRequest) PageSize(pageSize int32) *AuthorsApiGetRequest {
	r.pageSize = &pageSize
	return r
}

func (r *AuthorsApiGetRequest) IncludeNlpData(includeNlpData bool) *AuthorsApiGetRequest {
	r.includeNlpData = &includeNlpData
	return r
}

func (r *AuthorsApiGetRequest) HasNlp(hasNlp bool) *AuthorsApiGetRequest {
	r.hasNlp = &hasNlp
	return r
}

func (r *AuthorsApiGetRequest) Theme(theme string) *AuthorsApiGetRequest {
	r.theme = &theme
	return r
}

func (r *AuthorsApiGetRequest) NotTheme(notTheme string) *AuthorsApiGetRequest {
	r.notTheme = &notTheme
	return r
}

func (r *AuthorsApiGetRequest) NerName(nerName string) *AuthorsApiGetRequest {
	r.nerName = &nerName
	return r
}

func (r *AuthorsApiGetRequest) TitleSentimentMin(titleSentimentMin float32) *AuthorsApiGetRequest {
	r.titleSentimentMin = &titleSentimentMin
	return r
}

func (r *AuthorsApiGetRequest) TitleSentimentMax(titleSentimentMax float32) *AuthorsApiGetRequest {
	r.titleSentimentMax = &titleSentimentMax
	return r
}

func (r *AuthorsApiGetRequest) ContentSentimentMin(contentSentimentMin float32) *AuthorsApiGetRequest {
	r.contentSentimentMin = &contentSentimentMin
	return r
}

func (r *AuthorsApiGetRequest) ContentSentimentMax(contentSentimentMax float32) *AuthorsApiGetRequest {
	r.contentSentimentMax = &contentSentimentMax
	return r
}

func (r *AuthorsApiGetRequest) IptcTags(iptcTags interface{}) *AuthorsApiGetRequest {
	r.iptcTags = &iptcTags
	return r
}

func (r *AuthorsApiGetRequest) NotIptcTags(notIptcTags interface{}) *AuthorsApiGetRequest {
	r.notIptcTags = &notIptcTags
	return r
}

func (r *AuthorsApiGetRequest) IabTags(iabTags interface{}) *AuthorsApiGetRequest {
	r.iabTags = &iabTags
	return r
}

func (r *AuthorsApiGetRequest) NotIabTags(notIabTags interface{}) *AuthorsApiGetRequest {
	r.notIabTags = &notIabTags
	return r
}

func (r AuthorsApiGetRequest) Execute() (*FSearchResponse, *http.Response, error) {
	return r.ApiService.GetExecute(r)
}

/*
Get [Get] Search By Author Request

This endpoint allows you to search for articles by author. You need to specify the author name. You can also filter by language, country, source, and more.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param authorName
 @return AuthorsApiGetRequest
*/
func (a *AuthorsApiService) Get(authorName string) AuthorsApiGetRequest {
	return AuthorsApiGetRequest{
		ApiService: a,
		ctx: a.client.cfg.Context,
		authorName: authorName,
	}
}

// Execute executes the request
//  @return FSearchResponse
func (a *AuthorsApiService) GetExecute(r AuthorsApiGetRequest) (*FSearchResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FSearchResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthorsApiService.Get")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/authors"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.wordCountMin != nil && *r.wordCountMin < 0 {
		return localVarReturnValue, nil, reportError("wordCountMin must be greater than 0")
	}
	if r.wordCountMax != nil && *r.wordCountMax < 0 {
		return localVarReturnValue, nil, reportError("wordCountMax must be greater than 0")
	}
	if r.page != nil && *r.page < 0 {
		return localVarReturnValue, nil, reportError("page must be greater than 0")
	}
	if r.pageSize != nil && *r.pageSize < 0 {
		return localVarReturnValue, nil, reportError("pageSize must be greater than 0")
	}

	localVarQueryParams.Add("author_name", parameterToString(r.authorName, ""))
	if r.notAuthorName != nil {
		localVarQueryParams.Add("not_author_name", parameterToString(*r.notAuthorName, ""))
	}
	if r.sources != nil {
		localVarQueryParams.Add("sources", parameterToString(*r.sources, ""))
	}
	if r.predefinedSources != nil {
		localVarQueryParams.Add("predefined_sources", parameterToString(*r.predefinedSources, ""))
	}
	if r.notSources != nil {
		localVarQueryParams.Add("not_sources", parameterToString(*r.notSources, ""))
	}
	if r.lang != nil {
		localVarQueryParams.Add("lang", parameterToString(*r.lang, ""))
	}
	if r.notLang != nil {
		localVarQueryParams.Add("not_lang", parameterToString(*r.notLang, ""))
	}
	if r.countries != nil {
		localVarQueryParams.Add("countries", parameterToString(*r.countries, ""))
	}
	if r.notCountries != nil {
		localVarQueryParams.Add("not_countries", parameterToString(*r.notCountries, ""))
	}
	if r.from != nil {
		localVarQueryParams.Add("from_", parameterToString(*r.from, ""))
	}
	if r.to != nil {
		localVarQueryParams.Add("to_", parameterToString(*r.to, ""))
	}
	if r.publishedDatePrecision != nil {
		localVarQueryParams.Add("published_date_precision", parameterToString(*r.publishedDatePrecision, ""))
	}
	if r.byParseDate != nil {
		localVarQueryParams.Add("by_parse_date", parameterToString(*r.byParseDate, ""))
	}
	if r.sortBy != nil {
		localVarQueryParams.Add("sort_by", parameterToString(*r.sortBy, ""))
	}
	if r.rankedOnly != nil {
		localVarQueryParams.Add("ranked_only", parameterToString(*r.rankedOnly, ""))
	}
	if r.fromRank != nil {
		localVarQueryParams.Add("from_rank", parameterToString(*r.fromRank, ""))
	}
	if r.toRank != nil {
		localVarQueryParams.Add("to_rank", parameterToString(*r.toRank, ""))
	}
	if r.isHeadline != nil {
		localVarQueryParams.Add("is_headline", parameterToString(*r.isHeadline, ""))
	}
	if r.isOpinion != nil {
		localVarQueryParams.Add("is_opinion", parameterToString(*r.isOpinion, ""))
	}
	if r.isPaidContent != nil {
		localVarQueryParams.Add("is_paid_content", parameterToString(*r.isPaidContent, ""))
	}
	if r.parentUrl != nil {
		localVarQueryParams.Add("parent_url", parameterToString(*r.parentUrl, ""))
	}
	if r.allLinks != nil {
		localVarQueryParams.Add("all_links", parameterToString(*r.allLinks, ""))
	}
	if r.allDomainLinks != nil {
		localVarQueryParams.Add("all_domain_links", parameterToString(*r.allDomainLinks, ""))
	}
	if r.wordCountMin != nil {
		localVarQueryParams.Add("word_count_min", parameterToString(*r.wordCountMin, ""))
	}
	if r.wordCountMax != nil {
		localVarQueryParams.Add("word_count_max", parameterToString(*r.wordCountMax, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.includeNlpData != nil {
		localVarQueryParams.Add("include_nlp_data", parameterToString(*r.includeNlpData, ""))
	}
	if r.hasNlp != nil {
		localVarQueryParams.Add("has_nlp", parameterToString(*r.hasNlp, ""))
	}
	if r.theme != nil {
		localVarQueryParams.Add("theme", parameterToString(*r.theme, ""))
	}
	if r.notTheme != nil {
		localVarQueryParams.Add("not_theme", parameterToString(*r.notTheme, ""))
	}
	if r.nerName != nil {
		localVarQueryParams.Add("ner_name", parameterToString(*r.nerName, ""))
	}
	if r.titleSentimentMin != nil {
		localVarQueryParams.Add("title_sentiment_min", parameterToString(*r.titleSentimentMin, ""))
	}
	if r.titleSentimentMax != nil {
		localVarQueryParams.Add("title_sentiment_max", parameterToString(*r.titleSentimentMax, ""))
	}
	if r.contentSentimentMin != nil {
		localVarQueryParams.Add("content_sentiment_min", parameterToString(*r.contentSentimentMin, ""))
	}
	if r.contentSentimentMax != nil {
		localVarQueryParams.Add("content_sentiment_max", parameterToString(*r.contentSentimentMax, ""))
	}
	if r.iptcTags != nil {
		localVarQueryParams.Add("iptc_tags", parameterToString(*r.iptcTags, ""))
	}
	if r.notIptcTags != nil {
		localVarQueryParams.Add("not_iptc_tags", parameterToString(*r.notIptcTags, ""))
	}
	if r.iabTags != nil {
		localVarQueryParams.Add("iab_tags", parameterToString(*r.iabTags, ""))
	}
	if r.notIabTags != nil {
		localVarQueryParams.Add("not_iab_tags", parameterToString(*r.notIabTags, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AuthorsApiPostRequest struct {
	ctx context.Context
	ApiService *AuthorsApiService
	authorSearchRequest AuthorSearchRequest
}

func (r AuthorsApiPostRequest) Execute() (*FSearchResponse1, *http.Response, error) {
	return r.ApiService.PostExecute(r)
}

/*
Post [Post] Search By Author Request

This endpoint allows you to search for articles by author. You need to specify the author name. You can also filter by language, country, source, and more.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param authorSearchRequest
 @return AuthorsApiPostRequest
*/
func (a *AuthorsApiService) Post(authorSearchRequest AuthorSearchRequest) AuthorsApiPostRequest {
	return AuthorsApiPostRequest{
		ApiService: a,
		ctx: a.client.cfg.Context,
		authorSearchRequest: authorSearchRequest,
	}
}

// Execute executes the request
//  @return FSearchResponse1
func (a *AuthorsApiService) PostExecute(r AuthorsApiPostRequest) (*FSearchResponse1, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FSearchResponse1
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthorsApiService.Post")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/authors"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authorSearchRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
